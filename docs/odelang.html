<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<title>Ode Language Documentation</title>

<link rel="stylesheet" type="text/css" href="../styles/documentation.css">

</head>
<body>

<div class="content">

<h1>Ode Language Documentation</h1><h2>Literals</h2><h3>Boolean Literals</h3>

<p>The logical type, or the type of truth values. It has just two
literals: true and false.</p>

<p><code>false</code> => false</p><h3>Character Literals</h3>

<p>The type of characters. Literals are written with a single quote.
Examples: 'A '7 '; and so on. Unix style escapes are allowed.</p><h3>Integer Literals</h3>

<p>The type of negative, zero or positive integers. Literals are
written in decimal notation. Examples: -123 0 42.</p><h3>Set Literals</h3>

<p>The type of sets of small non-negative integers. The maximum is
platform dependent, typically the range is 0..31. Literals are
written inside curly braces.</p>

<p>Examples:</p>

<ul>
<li><code>{}</code></li>
<li><code>{0}</code></li>
<li><code>{1 3 5}</code></li>
<li><code>{19 18 17}</code></li>
</ul><h3>String Literals</h3>

<p>The type of strings of characters. Literals are written inside
double quotes. Examples: "" "A" "hello world" "123". Unix style
escapes are accepted.</p><h3>List Literals</h3>

<p>The type of lists of values of any type (including lists), or the
type of quoted programs which may contain operators or combinators.
Literals of this type are written inside square brackets.</p>

<p>Examples:</p>

<ul>
<li><code>[]</code></li>
<li><code>[3 512 -7]</code></li>
<li><code>[john mary]</code></li>
<li><code>['A 'C ['B]]</code></li>
<li><code>[dup *]</code></li>
</ul><h3>Float Literals</h3>

<p>The type of floating-point numbers. Literals of this type are
written with embedded decimal points (like 1.2) and optional
exponent specifiers (like 1.5E2).</p><h2>Definitions</h2><h2>Math</h2><h3>+ : M I -> N</h3>

<p>Numeric N is the result of adding integer I to numeric M. Also
supports float.</p><h3>succ : M -> N</h3>

<p>Numeric N is the successor of numeric M.</p><h3>div : I J -> K L</h3>

<p>Integers K and L are the quotient and remainder of dividing I by J.</p><h3>rem : I J -> K</h3>

<p>Integer K is the remainder of dividing I by J. Also supports float.</p><h3>- : M I -> N</h3>

<p>Numeric N is the result of subtracting integer I from numeric M.
Also supports float.</p><h3>* : I J -> K</h3>

<p>Integer K is the product of integers I and J. Also supports float.</p><h3>/ : I J -> K</h3>

<p>Integer K is the (rounded) ratio of integers I and J. Also
supports float.</p><h2>Boolean Operations</h2><h3>choice : B T F -> X</h3>

<p>If B is true, then X = T else X = F.</p><h3>or : X Y -> Z</h3>

<p>Z is the logical disjunction for truth values.</p><h3>xor : X Y -> Z</h3>

<p>Z is the logical exclusive disjunction for truth values.</p><h3>and : X Y -> Z</h3>

<p>Z is the logical conjunction for truth values.</p><h3>not : X -> Y</h3>

<p>Y is the logical negation for truth values.</p><h3>>= : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X greater than or equal to Y. Also supports float.</p><h3>> : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X greater than Y. Also supports float.</p><h3>!= : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X not equal to Y. Also supports float.</p><h3>= : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X equal to Y. Also supports float.</p><h3>&lt; : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X less than Y. Also supports float.</p><h3>&lt;= : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X less than or equal to Y. Also supports float.</p><h3>null : X -> B</h3>

<p>Tests for empty aggregate X or zero numeric.</p><h3>small : X -> B</h3>

<p>Tests whether aggregate X has 0 or 1 members, or numeric 0 or 1.</p><h2>Aggregate Operations</h2><h3>concat : S T -> U</h3>

<p>Sequence U is the concatenation of sequences S and T.</p><h3>size : A -> I</h3>

<p>Integer I is the number of elements of aggregate A.</p><h3>cons : X A -> B</h3>

<p>Aggregate B is A with a new member X (first member for sequences).</p><h3>uncons : A -> F R</h3>

<p>F and R are the first and the rest of non-empty aggregate A.</p><h3>i : [P] -> ...</h3>

<p>Executes P. So, [P] i == P.</p><h3>rest : A -> R</h3>

<p>R is the non-empty aggregate A with its first member removed.</p><h3>first : A -> F</h3>

<p>F is the first member of the non-empty aggregate A.</p><h2>Functional Operations</h2><h3>map : A [P] -> B</h3>

<p>Executes P on each member of aggregate A, collects results in same type aggregate B.</p><h3>fold : A V0 [P] -> V</h3>

<p>Starting with value V0, sequentially pushes members of aggregate A and combines with binary operator P to produce value V.</p><h3>primrec : X [I] [C] -> R</h3>

<p>Executes I to obtain an initial value R0. For integer X uses increasing
positive integers to X, combines by C for new R. For aggregate X uses
successive members and combines by C for new R.</p>

<p>In Joy there is a combinator for primitive recursion which has this pattern
built in and thus avoids the need for a definition. The primrec combinator
expects two quoted programs in addition to a data parameter. For an integer
data parameter it works like this: If the data parameter is zero, then the
first quotation has to produce the value to be returned. If the data
parameter is positive then the second has to combine the data parameter
with the result of applying the function to its predecessor. For the
factorial function the required quoted programs are very simple:</p>

<pre><code>[1] [*] primrec
</code></pre>

<p>computes the factorial recursively. There is no need for any definition.
For example, the following program computes the factorial of 5:</p>

<pre><code>5 [1] [*] primrec
</code></pre>

<p>It first pushes the number 5 and then it pushes the two short quoted
programs. At this point the stack contains three elements. Then the primrec
combinator is executed. It pops the two quotations off the stack and saves
them elsewhere. Then primrec tests whether the top element on the stack
(initially the 5) is equal to zero. If it is, it pops it off and executes
one of the quotations, the [1] which leaves 1 on the stack as the result.
Otherwise it pushes a decremented copy of the top element and recurses. On
the way back from the recursion it uses the other quotation, [*], to
multiply what is now a factorial on top of the stack by the second element
on the stack. When all is done, the stack contains 120, the factorial of 5.
As may be seen from this program, the usual branching of recursive
definitions is built into the combinator. The primrec combinator can be
used with many other quotation parameters to compute quite different
functions. It can also be used with data types other than integers. Joy has
many more combinators which can be used to calculate many functions without
forcing the user to give recursive or non-recursive definitions. Some of
the combinators are more data-specific than primrec, and others are far
more general.</p><h2>Input/Output</h2><p>rand : -> I</p>

<p>I is a random integer.</p><h2>Control Flow</h2><h3>ifte : [B] [T] [F] -> ...</h3>

<p>Executes B. If that yields true, then executes T else executes F.</p><h2>Definitions and Symbols</h2><h3>undefs : -> [...]</h3>

<p>Push a list of all undefined symbols in the current symbol table.</p><h3>body : U -> [P]</h3>

<p>Quotation [P] is the body of user-defined symbol U.</p>

<p>Example:</p>

<ul>
<li>�double == 2 *; [double] first body� => [2 *]</li>
</ul>

<p>Ode only:</p>

<p>User-defined symbol U can be a name or a name in a block.</p><h2>Basic Stack Operations</h2><h3>id : -></h3>

<p>Identity function, does nothing. Any program of the form P id Q
is equivalent to just P Q.</p><h3>dup : X -> X X</h3>

<p>Pushes an extra copy of X onto stack.</p><h3>swap : X Y -> Y X</h3>

<p>Interchanges X and Y on top of the stack.</p><h3>rollup : X Y Z -> Z X Y</h3>

<p>Moves X and Y up, moves Z down</p><h3>rolldown : X Y Z -> Y Z X</h3>

<p>Moves Y and Z down, moves X up.</p><h3>rotate : X Y Z -> Z Y X</h3>

<p>Interchanges X and Z.</p><h3>pop : X -></h3>

<p>Removes X from top of the stack.</p><h2>Advanced Stack</h2><h3>newstack : ... -></h3>

<p>Removes all items from the stack.</p><h3>stack : .. X Y Z -> .. X Y Z [Z Y X ..]</h3>

<p>Pushes the stack as a list.</p>

<p>(Note that when treating lists as stacks, the first element in the list
will be the top item of the stack.)</p><h3>unstack : [X Y ..] -> ..Y X</h3>

<p>The list [X Y ..] becomes the new stack.</p>

<p>(Note that when treating lists as stacks, the first element in the list
will be the top item of the stack.)</p><h3>infra : L1 [P] -> L2</h3>

<p>Using list L1 as stack, executes P and returns a new list L2. The first
element of L1 is used as the top of stack, and after execution of P the
top of stack becomes the first element of L2.</p>

<p>(Note that when treating lists as stacks, the first element in the list
will be the top item of the stack.)</p></div> <!-- #content -->

</body>
</html>