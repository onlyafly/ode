<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<title>Ode Language Documentation</title>

<link rel="stylesheet" type="text/css" href="../styles/documentation.css">

</head>
<body>

  <div class="content">

    <nav>
      <a href="../index.html">Ode Programming Language</a>
    </nav>

    <h1>Ode Language Documentation</h1>

    <p>
      <em>
        This documentation is borrowed from the  
        <a href="http://www.kevinalbrecht.com/code/joy-mirror/">original Joy language documentation</a>,
        with modifications to clarify how certain operators function in the Ode environment.
      </em>
    </p><h2>Literals</h2><h3>Boolean/Logical Literals</h3>

<p>The logical type, or the type of truth values. It has just two
literals: true and false.</p>

<p><code>false</code> => false</p><h3>Character Literals</h3>

<p>The type of characters. Literals are written with a single quote.
Examples: 'A '7 '; and so on. Unix style escapes are allowed.</p><h3>Integer Literals</h3>

<p>The type of negative, zero or positive integers. Literals are
written in decimal notation. Examples: -123 0 42.</p><h3>Set Literals</h3>

<p>The type of sets of small non-negative integers. The maximum is
platform dependent, typically the range is 0..31. Literals are
written inside curly braces.</p>

<p>Examples:</p>

<ul>
<li><code>{}</code></li>
<li><code>{0}</code></li>
<li><code>{1 3 5}</code></li>
<li><code>{19 18 17}</code></li>
</ul><h3>String Literals</h3>

<p>The type of strings of characters. Literals are written inside
double quotes. Examples: "" "A" "hello world" "123". Unix style
escapes are accepted.</p><h3>List Literals</h3>

<p>The type of lists of values of any type (including lists), or the
type of quoted programs which may contain operators or combinators.
Literals of this type are written inside square brackets.</p>

<p>Examples:</p>

<ul>
<li><code>[]</code></li>
<li><code>[3 512 -7]</code></li>
<li><code>[john mary]</code></li>
<li><code>['A 'C ['B]]</code></li>
<li><code>[dup *]</code></li>
</ul><h3>Float Literals</h3>

<p>The type of floating-point numbers. Literals of this type are
written with embedded decimal points (like 1.2) and optional
exponent specifiers (like 1.5E2).</p><h2>Definitions and Symbols</h2><h3>==</h3>

<p>Defines a definition.</p>

<pre><code>double == dup +;
</code></pre><h3>name : sym -> "sym"</h3>

<p>For operators and combinators, the string "sym" is the name of item sym,
for literals sym the result string is its type.</p><h3>intern : "sym" -> sym</h3>

<p>Pushes the item whose name is "sym".</p><h2>Math</h2><h3>+ : M I -> N</h3>

<p>Numeric N is the result of adding integer I to numeric M. Also
supports float.</p><h3>succ : M -> N</h3>

<p>Numeric N is the successor of numeric M.</p><h3>div : I J -> K L</h3>

<p>Integers K and L are the quotient and remainder of dividing I by J.</p><h3>rem : I J -> K</h3>

<p>Integer K is the remainder of dividing I by J. Also supports float.</p><h3>- : M I -> N</h3>

<p>Numeric N is the result of subtracting integer I from numeric M.
Also supports float.</p><h3>* : I J -> K</h3>

<p>Integer K is the product of integers I and J. Also supports float.</p><h3>/ : I J -> K</h3>

<p>Integer K is the (rounded) ratio of integers I and J. Also
supports float.</p><h3>maxint : -> N</h3>

<p>Pushes largest integer (platform dependent). Typically it is
32 bits.</p><h3>sign : N1 -> N2</h3>

<p>Integer N2 is the sign (-1 or 0 or +1) of integer N1, or float N2 is the sign (-1.0 or 0.0 or 1.0) of float N1.</p><h2>Boolean Operations</h2><h3>choice : B T F -> X</h3>

<p>If B is true, then X = T else X = F.</p><h3>or : X Y -> Z</h3>

<p>Z is the logical disjunction for truth values.</p><h3>xor : X Y -> Z</h3>

<p>Z is the logical exclusive disjunction for truth values.</p><h3>and : X Y -> Z</h3>

<p>Z is the logical conjunction for truth values.</p><h3>not : X -> Y</h3>

<p>Y is the logical negation for truth values.</p><h3>>= : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X greater than or equal to Y. Also supports float.</p><h3>> : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X greater than Y. Also supports float.</p><h3>!= : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X not equal to Y. Also supports float.</p><h3>= : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X equal to Y. Also supports float.</p><h3>&lt; : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X less than Y. Also supports float.</p><h3>&lt;= : X Y -> B</h3>

<p>Either both X and Y are numeric or both are strings or symbols. Tests whether X less than or equal to Y. Also supports float.</p><h3>null : X -> B</h3>

<p>Tests for empty aggregate X or zero numeric.</p><h3>small : X -> B</h3>

<p>Tests whether aggregate X has 0 or 1 members, or numeric 0 or 1.</p><h3>integer : X -> B</h3>

<p>Tests whether X is an integer.</p><h3>char : X -> B</h3>

<p>Tests whether X is a character.</p><h3>logical : X -> B</h3>

<p>Tests whether X is a logical.</p><h3>set : X -> B</h3>

<p>Tests whether X is a set.</p><h3>string : X -> B</h3>

<p>Tests whether X is a string.</p><h3>list : X -> B</h3>

<p>Tests whether X is a list.</p><h3>float : R -> B</h3>

<p>Tests whether R is a float.</p><h2>Aggregate Operations</h2><h3>concat : S T -> U</h3>

<p>Sequence U is the concatenation of sequences S and T.</p><h3>size : A -> I</h3>

<p>Integer I is the number of elements of aggregate A.</p><h3>cons : X A -> B</h3>

<p>Aggregate B is A with a new member X (first member for sequences).</p><h3>swons : A X -> B</h3>

<p>Aggregate B is A with a new member X (first member for sequences). This is
the same as cons, but with the arguments reversed.</p><h3>uncons : A -> F R</h3>

<p>F and R are the first and the rest of non-empty aggregate A.</p><h3>i : [P] -> ...</h3>

<p>Executes P. So, [P] i == P.</p><h3>rest : A -> R</h3>

<p>R is the non-empty aggregate A with its first member removed.</p><h3>first : A -> F</h3>

<p>F is the first member of the non-empty aggregate A.</p><h2>Functional Operations</h2><h3>map : A [P] -> B</h3>

<p>Executes P on each member of aggregate A, collects results in same type
aggregate B.</p><h3>fold : A V0 [P] -> V</h3>

<p>Starting with value V0, sequentially pushes members of aggregate A and
combines with binary operator P to produce value V.</p><h3>split : A [B] -> A1 A2</h3>

<p>Uses test B to split aggregate A into same type aggregates A1 and A2.</p>

<p>(Note: Preserves stack state before each test is run, restoring it after).</p><h2>Recursion</h2><h3>primrec : X [I] [C] -> R</h3>

<p>Executes I to obtain an initial value R0. For integer X uses increasing
positive integers to X, combines by C for new R. For aggregate X uses
successive members and combines by C for new R.</p>

<p>The primrec combinator
expects two quoted programs in addition to a data parameter. For an integer
data parameter it works like this: If the data parameter is zero, then the
first quotation has to produce the value to be returned. If the data
parameter is positive then the second has to combine the data parameter
with the result of applying the function to its predecessor. For the
factorial function the required quoted programs are very simple:</p>

<pre><code>[1] [*] primrec
</code></pre>

<p>computes the factorial recursively. There is no need for any definition.
For example, the following program computes the factorial of 5:</p>

<pre><code>5 [1] [*] primrec
</code></pre>

<p>It first pushes the number 5 and then it pushes the two short quoted
programs. At this point the stack contains three elements. Then the primrec
combinator is executed. It pops the two quotations off the stack and saves
them elsewhere. Then primrec tests whether the top element on the stack
(initially the 5) is equal to zero. If it is, it pops it off and executes
one of the quotations, the [1] which leaves 1 on the stack as the result.
Otherwise it pushes a decremented copy of the top element and recurses. On
the way back from the recursion it uses the other quotation, [*], to
multiply what is now a factorial on top of the stack by the second element
on the stack. When all is done, the stack contains 120, the factorial of 5.
As may be seen from this program, the usual branching of recursive
definitions is built into the combinator. The primrec combinator can be
used with many other quotation parameters to compute quite different
functions. It can also be used with data types other than integers.</p><h3>linrec : [P] [T] [R1] [R2] -> ...</h3>

<p>Executes P. If that yields true, executes T. Else executes R1, recurses,
executes R2.</p>

<p>A high proportion of recursively defined functions exhibit a very simple
pattern: There is some test, the if-part, which determines whether the
ground case obtains. If it does, then the non-recursive branch is executed,
the basis case of recursion. If it does not, then the recursive part is
executed, including one or more recursive calls.</p>

<p>The linrec combinator is
very similar to the genrec combinator. The essential difference is that
the bundled up quotation is immediately called before the rec2-part.
Consequently it can only be used for linear recursion.</p><h3>binrec : [B] [T] [R1] [R2] -> ...</h3>

<p>Executes B. If that yields true, executes T. Else uses R1 to produce two
intermediates, recurses on both, then executes R2 to combines their results.</p>

<p>In many recursive definitions there are two recursive calls of the function
being defined. This is the pattern of binary recursion, and it is used in
the usual definitions of quicksort and of the Fibonacci function. In
analogy with the linrec combinator for linear recursion, Joy has a binrec
combinator for binary recursion. The following will quicksort a list whose
members can be a mixture of anything except lists:</p>

<pre><code>quicksort ==
  [small]
  []
  [uncons [&gt;] split]
  [swapd cons concat]
  binrec;
</code></pre>

<p>And an example using the above quicksort:</p>

<p><code>[5 3 1 4 2] quicksort</code> => [1 2 3 4 5]</p><h3>genrec : [B] [T] [R1] [R2] -> ...</h3>

<p>Executes B, if that yields true executes T. Else executes R1 and then
[[B] [T] [R1] [R2] genrec] R2.</p>

<p>One of these is the genrec combinator which takes four program parameters
in addition to whatever data parameters it needs. Fourth from the top is an
if-part, followed by a then-part. If the if-part yields true, then the
then-part is executed and the combinator terminates. The other two
parameters are the rec1-part and the rec2part. If the if-part yields false,
the rec1-part is executed. Following that the four program parameters and
the combinator are again pushed onto the stack bundled up in a quoted form.
Then the rec2-part is executed, where it will find the bundled form.
Typically it will then execute the bundled form, either with i or with
app2, or some other combinator. The following pieces of code, without any
definitions, compute the factorial, the (naive) Fibonacci and quicksort.
The four parts are here aligned to make comparisons easier.</p><h2>Input/Output</h2><h3>rand : -> I</h3>

<p>I is a random integer.</p><h2>Control Flow</h2><h3>ifte : [B] [T] [F] -> ...</h3>

<p>Preserves the stack state, then executes B. The stack state is then
restored. If B yielded true, then executes T else executes F.</p>

<p>Put another way, it saves the stack before calling the conditional
and restores it before calling the appropriate branch, therefore
hiding any changing of the stack the conditional may have done.</p><h2>Definitions and Symbols</h2><h3>body : U -> [P]</h3>

<p>Quotation [P] is the body of user-defined symbol U.</p>

<p>Example:</p>

<ul>
<li><code>double == 2 *; [double] first body</code> => [2 *]</li>
</ul>

<p>Ode only:</p>

<p>User-defined symbol U can be a name or a name in a list.</p><h2>Basic Stack Operations</h2><h3>id : -></h3>

<p>Identity function, does nothing. Any program of the form P id Q
is equivalent to just P Q.</p><h3>dup : X -> X X</h3>

<p>Pushes an extra copy of X onto stack.</p><h3>swap : X Y -> Y X</h3>

<p>Interchanges X and Y on top of the stack.</p><h3>rollup : X Y Z -> Z X Y</h3>

<p>Moves X and Y up, moves Z down</p><h3>rolldown : X Y Z -> Y Z X</h3>

<p>Moves Y and Z down, moves X up.</p><h3>rotate : X Y Z -> Z Y X</h3>

<p>Interchanges X and Z.</p><h3>pop : X -></h3>

<p>Removes X from top of the stack.</p><h3>dip : X [P] -> ... X</h3>

<p>Saves X, executes P, pushes X back.</p><h2>Advanced Stack Operations</h2><h3>newstack : ... -></h3>

<p>Removes all items from the stack.</p><h3>stack : .. X Y Z -> .. X Y Z [Z Y X ..]</h3>

<p>Pushes the stack as a list.</p>

<p>(Note that when treating lists as stacks, the first element in the list
will be the top item of the stack.)</p><h3>unstack : [X Y ..] -> ..Y X</h3>

<p>The list [X Y ..] becomes the new stack.</p>

<p>(Note that when treating lists as stacks, the first element in the list
will be the top item of the stack.)</p><h3>infra : L1 [P] -> L2</h3>

<p>Using list L1 as stack, executes P and returns a new list L2. The first
element of L1 is used as the top of stack, and after execution of P the
top of stack becomes the first element of L2.</p>

<p>(Note that when treating lists as stacks, the first element in the list
will be the top item of the stack.)</p><h3>unary : X [P] -> R</h3>

<p>Executes P, which leaves R on top of the stack. No matter how many
parameters this consumes, exactly one is removed from the stack.</p><h3>unary2 : X1 X2 [P] -> R1 R2</h3>

<p>Executes P twice, with X1 and X2 on top of the stack. Returns the
two values R1 and R2.</p><h3>unary3 : X1 X2 X3 [P] -> R1 R2 R3</h3>

<p>Executes P three times, with Xi, returns Ri (i = 1..3).</p><h3>unary4 : X1 X2 X3 X4 [P] -> R1 R2 R3 R4</h3>

<p>Executes P four times, with Xi, returns Ri (i = 1..4).</p><h2>Not Yet Implemented</h2>

<p><em>These operators are part of Joy, but have not yet been implemented.</em></p>

<h3>undefs : -> [...]</h3>

<p>Push a list of all undefined symbols in the current symbol table.</p>

<h3>strtol : S I -> J</h3>

<p>String S is converted to the integer J using base I. If I = 0, assumes
base 10, but leading "0" means base 8 and leading "0x" means base 16.</p>

<h3>strtod : S -> R</h3>

<p>String S is converted to the float R.</p>

<h3>format : N C I J -> S</h3>

<p>S is the formatted version of N in mode C ('d or 'i = decimal,
'o = octal, 'x or 'X = hex with lower or upper case letters) with
maximum width I and minimum width J.</p>

<h3>formatf : F C I J -> S</h3>

<p>S is the formatted version of F in mode C ('e or 'E = exponential,
'f = fractional, 'g or G = general with lower or upper case letters)
with maximum width I and precision J.</p>

<h3>srand : I -></h3>

<p>Sets the random integer seed to integer I.</p>

<h3>max : N1 N2 -> N</h3>

<p>N is the maximum of numeric values N1 and N2. Also supports float.</p>

<h3>min : N1 N2 -> N</h3>

<p>N is the minimum of numeric values N1 and N2. Also supports float.</p>

<h3>compare : A B -> I</h3>

<p>I (=-1,0,+1) is the comparison of aggregates A and B. The values
correspond to the predicates &lt;=, =, >=.</p>

<h3>at : A I -> X</h3>

<p>X (= A[I]) is the member of A at position I.</p>

<h3>of : I A -> X</h3>

<p>X (= A[I]) is the I-th member of aggregate A.</p>

<h3>opcase : X [..[X Xs]..] -> [Xs]</h3>

<p>Indexing on type of X, returns the list [Xs].</p>

<h3>case : X [..[X Y]..] -> Y i</h3>

<p>Indexing on the value of X, execute the matching Y.</p>

<h3>unswons : A -> R F</h3>

<p>R and F are the rest and the first of non-empty aggregate A.</p>

<h3>drop : A N -> B</h3>

<p>Aggregate B is the result of deleting the first N elements of A.</p>

<h3>take : A N -> B</h3>

<p>Aggregate B is the result of retaining just the first N elements
of A.</p>

<h3>enconcat : X S T -> U</h3>

<p>Sequence U is the concatenation of sequences S and T with X inserted
between S and T (== swapd cons concat)</p>

<h3>equal : T U -> B</h3>

<p>(Recursively) tests whether trees T and U are identical.</p>

<h3>has : A X -> B</h3>

<p>Tests whether aggregate A has X as a member.</p>

<h3>in : X A -> B</h3>

<p>Tests whether X is a member of aggregate A.</p>

<h3>leaf : X -> B</h3>

<p>Tests whether X is not a list.</p>

<h3>user : X -> B</h3>

<p>Tests whether X is a user-defined symbol.</p>

<h3>file : F -> B</h3>

<p>Tests whether F is a file.</p>

<h3>x : [P]i -> ...</h3>

<p>Executes P without popping [P]. So, [P] x == [P] P.</p>

<h3>app1 : X [P] -> R</h3>

<p>Executes P, pushes result R on stack without X.</p>

<h3>app11 : X Y [P] -> R</h3>

<p>Executes P, pushes result R on stack.</p>

<h3>app12 : X Y1 Y2 [P] -> R1 R2</h3>

<p>Executes P twice, with Y1 and Y2, returns R1 and R2.</p>

<h3>construct : [P] [[P1] [P2] ..] -> R1 R2 ..</h3>

<p>Saves state of stack and then executes [P]. Then executes each [Pi] to
give Ri pushed onto saved stack.</p>

<h3>nullary : [P] -> R</h3>

<p>Executes P, which leaves R on top of the stack. No matter how many
parameters this consumes, none are removed from the stack.</p>

<h3>binary : X Y [P] -> R</h3>

<p>Executes P, which leaves R on top of the stack. No matter how many
parameters this consumes, exactly two are removed from the stack.</p>

<h3>ternary : X Y Z [P] -> R</h3>

<p>Executes P, which leaves R on top of the stack. No matter how many
parameters this consumes, exactly three are removed from the stack.</p>

<h3>cleave : X [P1] [P2] -> R1 R2</h3>

<p>Executes P1 and P2, each with X on top, producing two results.</p>

<h3>branch : B [T] [F] -> ...</h3>

<p>If B is true, then executes T else executes F.</p>

<h3>ifinteger : X [T] [E] -> ...</h3>

<p>If X is an integer, executes T else executes E.</p>

<h3>ifchar : X [T] [E] -> ...</h3>

<p>If X is a character, executes T else executes E.</p>

<h3>iflogical : X [T] [E] -> ...</h3>

<p>If X is a logical or truth value, executes T else executes E.</p>

<h3>ifset : X [T] [E] -> ...</h3>

<p>If X is a set, executes T else executes E.</p>

<h3>ifstring : X [T] [E] -> ...</h3>

<p>If X is a string, executes T else executes E.</p>

<h3>iflist : X [T] [E] -> ...</h3>

<p>If X is a list, executes T else executes E.</p>

<h3>iffloat : X [T] [E] -> ...</h3>

<p>If X is a float, executes T else executes E.</p>

<h3>iffile : X [T] [E] -> ...</h3>

<p>If X is a file, executes T else executes E.</p>

<h3>cond : [..[[Bi] Ti]..[D]] -> ...</h3>

<p>Tries each Bi. If that yields true, then executes Ti and exits. If no Bi
yields true, executes default D.</p>

<h3>while : [B] [D] -> ...</h3>

<p>While executing B yields true executes D.</p>

<h3>tailrec : [P] [T] [R1] -> ...</h3>

<p>Executes P. If that yields true, executes T. Else executes R1, recurses.</p>

<h3>condlinrec : [ [C1] [C2] .. [D] ] -> ...</h3>

<p>Each [Ci] is of the forms [[B] [T]] or [[B] [R1] [R2]]. Tries each B. If
that yields true and there is just a [T], executes T and exit. If there
are [R1] and [R2], executes R1, recurses, executes R2. Subsequent case
are ignored. If no B yields true, then [D] is used. It is then of the
forms [[T]] or [[R1] [R2]]. For the former, executes T. For the latter
executes R1, recurses, executes R2.</p>

<h3>step : A [P] -> ...</h3>

<p>Sequentially putting members of aggregate A onto stack, executes P for
each member of A.</p>

<h3>times : N [P] -> ...</h3>

<p>N times executes P.</p>

<h3>filter : A [B] -> A1</h3>

<p>Uses test B to filter aggregate A producing sametype aggregate A1.</p>

<h3>some : A [B] -> X</h3>

<p>Applies test B to members of aggregate A, X = true if some pass.</p>

<h3>all : A [B] -> X</h3>

<p>Applies test B to members of aggregate A, X = true if all pass.</p>

<h3>treestep : T [P] -> ...</h3>

<p>Recursively traverses leaves of tree T, executes P for each leaf.</p>

<h3>treerec : T [O] [C] -> ...</h3>

<p>T is a tree. If T is a leaf, executes O. Else executes [[O] [C] treerec] C.</p>

<h3>treegenrec : T [O1] [O2] [C] -> ...</h3>

<p>T is a tree. If T is a leaf, executes O1. Else executes O2 and then
[[O1] [O2] [C] treegenrec] C.</p>

<h3>neg : I -> J</h3>

<p>Integer J is the negative of integer I. Also supports float.</p>

<h3>ord : C -> I</h3>

<p>Integer I is the Ascii value of character C (or logical or integer).</p>

<h3>chr : I -> C</h3>

<p>C is the character whose Ascii value is integer I (or logical or character).</p>

<h3>abs : N1 -> N2</h3>

<p>Integer N2 is the absolute value (0,1,2..) of integer N1, or float N2 is the absolute value (0.0 ..) of float N1</p>

<h3>acos : F -> G</h3>

<p>G is the arc cosine of F.</p>

<h3>asin : F -> G</h3>

<p>G is the arc sine of F.</p>

<h3>atan : F -> G</h3>

<p>G is the arc tangent of F.</p>

<h3>atan2 : F G -> H</h3>

<p>H is the arc tangent of F / G.</p>

<h3>ceil : F -> G</h3>

<p>G is the float ceiling of F.</p>

<h3>cos : F -> G</h3>

<p>G is the cosine of F.</p>

<h3>cosh : F -> G</h3>

<p>G is the hyperbolic cosine of F.</p>

<h3>exp : F -> G</h3>

<p>G is e (2.718281828...) raised to the Fth power.</p>

<h3>floor : F -> G</h3>

<p>G is the floor of F.</p>

<h3>frexp : F -> G I</h3>

<p>G is the mantissa and I is the exponent of F. Unless F = 0, 0.5 &lt;= abs(G) &lt; 1.0.</p>

<h3>ldexp : F I -> G</h3>

<p>G is F times 2 to the Ith power.</p>

<h3>log : F -> G</h3>

<p>G is the natural logarithm of F.</p>

<h3>log10 : F -> G</h3>

<p>G is the common logarithm of F.</p>

<h3>modf : F -> G H</h3>

<p>G is the fractional part and H is the integer part (but expressed as a float) of F.</p>

<h3>pow : F G -> H</h3>

<p>H is F raised to the Gth power.</p>

<h3>sin : F -> G</h3>

<p>G is the sine of F.</p>

<h3>sinh : F -> G</h3>

<p>G is the hyperbolic sine of F.</p>

<h3>sqrt : F -> G</h3>

<p>G is the square root of F.</p>

<h3>tan : F -> G</h3>

<p>G is the tangent of F.</p>

<h3>tanh : F -> G</h3>

<p>G is the hyperbolic tangent of F.</p>

<h3>trunc : F -> I</h3>

<p>I is an integer equal to the float F truncated toward zero.</p><h2>Notes on Joy</h2>

<p><em>These operators are mentioned occassionally in Joy examples, but have been
replaced by new operations by Manfred von Thun, original author of Joy,
himself.</em></p>

<h3>app2 : X1 X2 [P] -> R1 R2</h3>

<p>Obsolescent. == unary2</p>

<h3>app3 : X1 X2 X3 [P] -> R1 R2 R3</h3>

<p>Obsolescent. == unary3</p>

<h3>app4 : X1 X2 X3 X4 [P] -> R1 R2 R3 R4</h3>

<p>Obsolescent. == unary4</p><h2>Other Operations (Not Implemented)</h2><h3>conts : -> [[P] [Q] ..]</h3>

<p>Pushes current continuations. Buggy, do not use.</p><h3>autoput : -> I</h3>

<p>Pushes current value of flag for automatic output, I = 0..2.</p><h3>undeferror : -> I</h3>

<p>Pushes current value of undefined-is-error flag.</p><h3>echo : -> I</h3>

<p>Pushes value of echo flag, I = 0..3.</p><h3>clock : -> I</h3>

<p>Pushes the integer value of current CPU usage in hundreds
of a second.</p><h3>time : -> I</h3>

<p>Pushes the current time (in seconds since the Epoch).</p><h3>localtime : I -> T</h3>

<p>Converts a time I into a list T representing local time: [year month day hour minute second isdst yearday weekday]. Month is 1 = January ... 12 = December; isdst is a Boolean flagging daylight savings/summer time; weekday is 0 = Monday ... 7 = Sunday.</p>

<h3>gmtime : I -> T</h3>

<p>Converts a time I into a list T representing universal time: [year month day hour minute second isdst yearday weekday]. Month is 1 = January ... 12 = December; isdst is false; weekday is 0 = Monday ... 7 = Sunday.</p>

<h3>mktime : T -> I</h3>

<p>Converts a list T representing local time into a time I. T is in the format generated by localtime.</p>

<h3>strftime : T S1 -> S2</h3>

<p>Formats a list T in the format of localtime or gmtime using string S1 and pushes the result S2.</p><h2>File I/O (Not Implemented)</h2><h3>File Literals</h3>

<p>The type of references to open I/O streams, typically but not
necessarily files. The only literals of this type are stdin,
stdout, and stderr.</p><h3>get : -> F</h3>

<p>Reads a factor from input and pushes it onto stack.</p><h3>put : X -></h3>

<p>Writes X to output, pops X off stack.</p><h3>putch : N -></h3>

<p>N : numeric, writes character whose ASCII is N.</p><h3>putchars : "abc.." -></h3>

<p>Writes abc.. (without quotes)</p><h3>fclose : S -></h3>

<p>Stream S is closed and removed from the stack.</p>

<h3>feof : S -> S B</h3>

<p>B is the end-of-file status of stream S.</p>

<h3>ferror : S -> S B</h3>

<p>B is the error status of stream S.</p>

<h3>fflush : S -> S</h3>

<p>Flush stream S, forcing all buffered output to be written.</p>

<h3>fgetch : S -> S C</h3>

<p>C is the next available character from stream S.</p>

<h3>fgets : S -> S L</h3>

<p>L is the next available line (as a string) from stream S.</p>

<h3>fopen : P M -> S</h3>

<p>The file system object with pathname P is opened with mode M (r, w, a, etc.) and stream object S is pushed; if the open fails, file:NULL is pushed.</p>

<h3>fread : S I -> S L</h3>

<p>I bytes are read from the current position of stream S and returned as a list of I integers.</p>

<h3>fwrite : S L -> S</h3>

<p>A list of integers are written as bytes to the current position of stream S.</p>

<h3>fremove : P -> B</h3>

<p>The file system object with pathname P is removed from the file system. is a boolean indicating success or failure.</p>

<h3>frename : P1 P2 -> B</h3>

<p>The file system object with pathname P1 is renamed to P2. B is a boolean indicating success or failure.</p>

<h3>fput : S X -> S</h3>

<p>Writes X to stream S, pops X off stack.</p>

<h3>fputch : S C -> S</h3>

<p>The character C is written to the current position of stream S.</p>

<h3>fputchars : S "abc.." -> S</h3>

<p>The string abc.. (no quotes) is written to the current position of stream S.</p>

<h3>fputstring : S "abc.." -> S</h3>

<p>== fputchars, as a temporary alternative.</p>

<h3>fseek : S P W -> S</h3>

<p>Stream S is repositioned to position P relative to whence-point W, where W = 0, 1, 2 for beginning, current position, end respectively.</p>

<h3>ftell : S -> S I</h3>

<p>I is the current position of stream S.</p><h2>Sets (Not Implemented)</h2><h3>setsize : -> N</h3>

<p>Pushes the maximum number of elements in a set (platform
dependent). Typically it is 32, and set members are in the
range 0..31.</p><h3>or : X Y -> Z</h3>

<p>Z is the union of sets X and Y.</p><h3>xor : X Y -> Z</h3>

<p>Z is the symmetric difference of sets X and Y.</p><h3>and : X Y -> Z</h3>

<p>Z is the intersection of sets X and Y.</p><h3>not : X -> Y</h3>

<p>Y is the complement of set X.</p><h2>System Specific Operations (Not Implemented)</h2>

<p><em>These operations do not make sense in the current web-based environment,
so are not currently implemented.</em></p><h3>help : -></h3>

<p>Lists all defined symbols, including those from library files. Then lists all primitives of raw Joy (There is a variant: "_help" which lists hidden symbols).</p>

<h3>helpdetail : [ S1 S2 .. ]</h3>

<p>Gives brief help on each symbol S in the list.</p>

<h3>manual : -></h3>

<p>Writes this manual of all Joy primitives to output file.</p>

<h3>setautoput : I -></h3>

<p>Sets value of flag for automatic put to I (if I = 0, none; if I = 1, put; if I = 2, stack.</p>

<h3>setundeferror : I -></h3>

<p>Sets flag that controls behavior of undefined functions (0 = no error, 1 = error).</p>

<h3>setecho : I -></h3>

<p>Sets value of echo flag for listing. I = 0: no echo, 1: echo, 2: with tab, 3: and linenumber.</p>

<h3>gc : -></h3>

<p>Initiates garbage collection.</p>

<h3>system : "command" -></h3>

<p>Escapes to shell, executes string "command". The string may cause execution of another program. When that has finished, the process returns to Joy.</p>

<h3>getenv : "variable" -> "value"</h3>

<p>Retrieves the value of the environment variable "variable".</p>

<h3>argv : -> A</h3>

<p>Creates an aggregate A containing the interpreter's command line arguments.</p>

<h3>argc : -> I</h3>

<p>Pushes the number of command line arguments. This is quivalent to 'argv size'.</p>

<h3>include : "filnam.ext" -></h3>

<p>Transfers input to file whose name is "filnam.ext". On end-of-file returns to previous input file.</p>

<h3>abort : -></h3>

<p>Aborts execution of current Joy program, returns to Joy main cycle.</p>

<h3>quit : -></h3>

<p>Exit from Joy.</p></div> <!-- .content -->

</body>
</html>